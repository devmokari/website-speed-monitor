<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Insights Dashboard</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 16px; }
    h1 { margin-bottom: 12px; }
    .charts { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px; }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 12px; background: #fafafa; }
    select { padding: 6px 10px; font-size: 16px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Insights Dashboard</h1>
  <label>Select URL: <select id="urls"></select></label>

  <div class="charts">
    <div class="card">
      <h3>Mobile Score</h3>
      <canvas id="mobileChart" height="180"></canvas>
    </div>
    <div class="card">
      <h3>Desktop Score</h3>
      <canvas id="desktopChart" height="180"></canvas>
    </div>
  </div>

  <script>
    let mobileChart, desktopChart;

    const zScore95 = 1.96;

    const dayKeyFormatter = new Intl.DateTimeFormat('en-CA', {
      timeZone: 'Australia/Melbourne',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    });

    const dayLabelFormatter = new Intl.DateTimeFormat('en-AU', {
      timeZone: 'Australia/Melbourne',
      month: 'short',
      day: 'numeric'
    });

    function unionLabels(mobile, desktop) {
      const set = new Set();
      mobile.forEach(p => set.add(p.t));
      desktop.forEach(p => set.add(p.t));
      return Array.from(set).sort();
    }

    function toSeries(points, labels) {
      const map = Object.fromEntries(points.map(p => [p.t, p]));
      return labels.map(l => map[l] ?? null);
    }

    function toMelbourneDay(tsUtc) {
      return dayKeyFormatter.format(new Date(tsUtc));
    }

    function formatDay(dayKey) {
      const [year, month, day] = dayKey.split('-').map(Number);
      return dayLabelFormatter.format(new Date(Date.UTC(year, month - 1, day)));
    }

    function aggregateDaily(points) {
      const buckets = new Map();
      points.forEach(p => {
        const dayKey = toMelbourneDay(p.t);
        if (!buckets.has(dayKey)) buckets.set(dayKey, []);
        buckets.get(dayKey).push(p.y);
      });

      return Array.from(buckets.entries())
        .map(([day, values]) => {
          const n = values.length;
          const mean = values.reduce((sum, v) => sum + v, 0) / n;
          let se = 0;
          if (n > 1) {
            const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / (n - 1);
            se = Math.sqrt(variance / n);
          }
          const margin = se * zScore95;
          return {
            t: day,
            mean,
            lower: mean - margin,
            upper: mean + margin,
          };
        })
        .sort((a, b) => a.t.localeCompare(b.t));
    }

    const errorBarPlugin = {
      id: 'errorBars',
      afterDatasetsDraw(chart) {
        const { ctx, scales: { y } } = chart;
        chart.data.datasets.forEach((dataset, datasetIndex) => {
          const bars = dataset.errorBars || [];
          const meta = chart.getDatasetMeta(datasetIndex);
          bars.forEach((bar, i) => {
            if (!bar || bar.lower == null || bar.upper == null) return;
            const point = meta.data[i];
            if (!point) return;
            const x = point.x;
            const yTop = y.getPixelForValue(bar.upper);
            const yBottom = y.getPixelForValue(bar.lower);
            ctx.save();
            ctx.strokeStyle = dataset.borderColor;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x, yTop);
            ctx.lineTo(x, yBottom);
            ctx.moveTo(x - 4, yTop);
            ctx.lineTo(x + 4, yTop);
            ctx.moveTo(x - 4, yBottom);
            ctx.lineTo(x + 4, yBottom);
            ctx.stroke();
            ctx.restore();
          });
        });
      }
    };

    Chart.register(errorBarPlugin);

    function renderCharts(data) {
      const mobileDaily = aggregateDaily(data.mobile);
      const desktopDaily = aggregateDaily(data.desktop);

      const labelsRaw = unionLabels(mobileDaily, desktopDaily);
      const labelsFormatted = labelsRaw.map(formatDay);
      const mobileSeries = toSeries(mobileDaily, labelsRaw);
      const desktopSeries = toSeries(desktopDaily, labelsRaw);
      const mobileData = mobileSeries.map(p => p ? p.mean : null);
      const desktopData = desktopSeries.map(p => p ? p.mean : null);

      const commonOptions = {
        type: 'line',
        options: {
          responsive: true,
          scales: {
            x: { title: { display: true, text: 'Day (Melbourne)' }, ticks: { maxRotation: 45, minRotation: 45 } },
            y: { title: { display: true, text: 'Score (0-100)' }, suggestedMin: 0, suggestedMax: 100 }
          }
        }
      };

      if (mobileChart) mobileChart.destroy();
      mobileChart = new Chart(
        document.getElementById('mobileChart'),
        {
          ...commonOptions,
          data: {
            labels: labelsFormatted,
            datasets: [{
              label: 'Mobile (mean ±95% CI)',
              data: mobileData,
              borderColor: '#0a66c2',
              backgroundColor: 'rgba(10,102,194,0.2)',
              errorBars: mobileSeries
            }]
          }
        }
      );

      if (desktopChart) desktopChart.destroy();
      desktopChart = new Chart(
        document.getElementById('desktopChart'),
        {
          ...commonOptions,
          data: {
            labels: labelsFormatted,
            datasets: [{
              label: 'Desktop (mean ±95% CI)',
              data: desktopData,
              borderColor: '#22a06b',
              backgroundColor: 'rgba(34,160,107,0.2)',
              errorBars: desktopSeries
            }]
          }
        }
      );
    }

    async function loadUrls() {
      const res = await fetch("/urls");
      const data = await res.json();
      const dropdown = document.getElementById("urls");
      dropdown.innerHTML = "";

      data.urls.forEach(url => {
        const opt = document.createElement("option");
        opt.value = url;
        opt.textContent = url;
        dropdown.appendChild(opt);
      });

      if (data.urls.length > 0) {
        dropdown.value = data.urls[0];
        fetchData(data.urls[0]);
      }
    }

    async function fetchData(url) {
      const res = await fetch("/data?url=" + encodeURIComponent(url));
      const json = await res.json();
      renderCharts(json);
    }

    document.getElementById("urls").addEventListener("change", e => {
      fetchData(e.target.value);
    });

    loadUrls();
  </script>
</body>
</html>
